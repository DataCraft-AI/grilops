<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Geometry - grilops API documentation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Geometry";
    var mkdocs_page_input_path = "geometry.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> grilops API documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">API</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../symbols/">Symbols</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Geometry</a>
    <ul class="subnav">
            
    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../grids/">Grids</a>
                </li>
                <li class="">
                    
    <a class="" href="../loops/">Loops</a>
                </li>
                <li class="">
                    
    <a class="" href="../regions/">Regions</a>
                </li>
                <li class="">
                    
    <a class="" href="../shapes/">Shapes</a>
                </li>
                <li class="">
                    
    <a class="" href="../sightlines/">Sightlines</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">grilops API documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>API &raquo;</li>
        
      
    
    <li>Geometry</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="grilops.geometry">grilops.geometry</h1>

<p>This module supports geometric objects useful in modeling grids of cells.
<h2 id="grilops.geometry.Vector">Vector</h2></p>
<pre><code class="python">Vector(self, /, *args, **kwargs)
</code></pre>

<p>A vector representing an offset in two dimensions.</p>
<p><strong>Attributes</strong></p>
<ul>
<li><code>dy (int)</code>: The relative distance in the y dimension.</li>
<li><code>dx (int)</code>: The relative distance in the x dimension.</li>
</ul>
<h3 id="grilops.geometry.Vector.dx">dx</h3>

<p>Alias for field number 1
<h3 id="grilops.geometry.Vector.dy">dy</h3></p>
<p>Alias for field number 0
<h3 id="grilops.geometry.Vector.negate">negate</h3></p>
<pre><code class="python">Vector.negate(self) -&gt; 'Vector'
</code></pre>

<p>Returns a vector that's the negation of this one.
<h3 id="grilops.geometry.Vector.translate">translate</h3></p>
<pre><code class="python">Vector.translate(self, d:'Vector') -&gt; 'Vector'
</code></pre>

<p>Translates this vector's endpoint in the given direction.
<h2 id="grilops.geometry.Point">Point</h2></p>
<pre><code class="python">Point(self, /, *args, **kwargs)
</code></pre>

<p>A point, generally corresponding to the center of a grid cell.</p>
<p><strong>Attributes</strong></p>
<ul>
<li><code>y (int)</code>: The location in the y dimension.</li>
<li><code>x (int)</code>: The location in the x dimension.</li>
</ul>
<h3 id="grilops.geometry.Point.x">x</h3>

<p>Alias for field number 1
<h3 id="grilops.geometry.Point.y">y</h3></p>
<p>Alias for field number 0
<h3 id="grilops.geometry.Point.translate">translate</h3></p>
<pre><code class="python">Point.translate(self, d:grilops.geometry.Vector) -&gt; 'Point'
</code></pre>

<p>Translates this point in the given direction.
<h2 id="grilops.geometry.Neighbor">Neighbor</h2></p>
<pre><code class="python">Neighbor(self, /, *args, **kwargs)
</code></pre>

<p>Properties of a cell that is a neighbor of another.</p>
<p><strong>Attributes</strong></p>
<ul>
<li><code>location (Point)</code>: The location of the cell.</li>
<li><code>direction (Vector)</code>: The direction from the original cell.</li>
<li><code>symbol (z3.ArithRef)</code>: The symbol constant of the cell.</li>
</ul>
<h3 id="grilops.geometry.Neighbor.direction">direction</h3>

<p>Alias for field number 1
<h3 id="grilops.geometry.Neighbor.location">location</h3></p>
<p>Alias for field number 0
<h3 id="grilops.geometry.Neighbor.symbol">symbol</h3></p>
<p>Alias for field number 2
<h2 id="grilops.geometry.Lattice">Lattice</h2></p>
<pre><code class="python">Lattice(self, /, *args, **kwargs)
</code></pre>

<p>A set of points corresponding to a lattice.
<h3 id="grilops.geometry.Lattice.points">points</h3></p>
<p>(List[Point]): The points in the lattice, sorted.
<h3 id="grilops.geometry.Lattice.point_to_index">point_to_index</h3></p>
<pre><code class="python">Lattice.point_to_index(self, point:grilops.geometry.Point) -&gt; Union[int, NoneType]
</code></pre>

<p>Returns the index of a point in the lattice's ordered list.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>point (Point)</strong>: The point to get the index of.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(Optional[int])</code>: The index of the point in the ordered list.
    None if the point is not in the list.</p>
<h3 id="grilops.geometry.Lattice.edge_sharing_directions">edge_sharing_directions</h3>

<pre><code class="python">Lattice.edge_sharing_directions(self) -&gt; List[Tuple[str, grilops.geometry.Vector]]
</code></pre>

<p>(List[Tuple[str, Vector]]): A list of edge-sharing directions.</p>
<p>Each entry in the returned list includes the name of an
edge-sharing direction and the vector representing that direction.
Edge sharing (also known as orthogonal adjacency) is the
relationship between grid cells that share an edge.</p>
<h3 id="grilops.geometry.Lattice.vertex_sharing_directions">vertex_sharing_directions</h3>

<pre><code class="python">Lattice.vertex_sharing_directions(self) -&gt; List[Tuple[str, grilops.geometry.Vector]]
</code></pre>

<p>(List[Tuple[str, Vector]]): A list of vertex-sharing directions.</p>
<p>Each entry in the returned list includes the name of a
vertex-sharing direction and the vector representing that
direction.  Vertex sharing (also known as touching adjacency) is
the relationship between grid cells that share a vertex.</p>
<h3 id="grilops.geometry.Lattice.edge_sharing_points">edge_sharing_points</h3>

<pre><code class="python">Lattice.edge_sharing_points(self, point:grilops.geometry.Point) -&gt; List[grilops.geometry.Point]
</code></pre>

<p>Returns the points that share an edge with the given cell.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>point (Point)</strong>: The point of the given cell.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Point])</code>: A list of points in the lattice that correspond
    to cells that share an edge with the given cell.</p>
<h3 id="grilops.geometry.Lattice.vertex_sharing_points">vertex_sharing_points</h3>

<pre><code class="python">Lattice.vertex_sharing_points(self, point:grilops.geometry.Point) -&gt; List[grilops.geometry.Point]
</code></pre>

<p>Returns a list of points sharing a vertex with the given cell.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>point (Point)</strong>: The point of the given cell.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Point])</code>: A list of points in the lattice corresponding to
   cells that share a vertex with the given cell.</p>
<h3 id="grilops.geometry.Lattice.edge_sharing_neighbors">edge_sharing_neighbors</h3>

<pre><code class="python">Lattice.edge_sharing_neighbors(self, cell_map:Dict[grilops.geometry.Point, z3.z3.ArithRef], p:grilops.geometry.Point) -&gt; List[grilops.geometry.Neighbor]
</code></pre>

<p>Returns a list of neighbors sharing an edge with the given cell.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>cell_map (Dict[Point, ArithRef])</strong>: A dictionary mapping points in
    the lattice to z3 constants.</li>
<li><strong>p (Point)</strong>: Point of the given cell.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Neighbor])</code>: The neighbor structures corresponding to the cells
    that share an edge with the given cell.</p>
<h3 id="grilops.geometry.Lattice.vertex_sharing_neighbors">vertex_sharing_neighbors</h3>

<pre><code class="python">Lattice.vertex_sharing_neighbors(self, cell_map:Dict[grilops.geometry.Point, z3.z3.ArithRef], p:grilops.geometry.Point) -&gt; List[grilops.geometry.Neighbor]
</code></pre>

<p>Returns a list of neighbors sharing a vertex with the given cell.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>cell_map (Dict[Point, ArithRef])</strong>: A dictionary mapping points in
    the lattice to z3 constants.</li>
<li><strong>p (Point)</strong>: Point of the given cell.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Neighbor])</code>: The neighbor structures corresponding to the cells
    that share a vertex with the given cell.</p>
<h3 id="grilops.geometry.Lattice.label_for_direction_pair">label_for_direction_pair</h3>

<pre><code class="python">Lattice.label_for_direction_pair(self, d1:str, d2:str) -&gt; str
</code></pre>

<p>Returns the label for a pair of edge-sharing direction names.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>d1 (str)</strong>: The first direction (e.g., "N", "S", etc.)</li>
<li><strong>d2 (str)</strong>: The second direction.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(str)</code>: The label representing both directions.</p>
<h3 id="grilops.geometry.Lattice.transformation_functions">transformation_functions</h3>

<pre><code class="python">Lattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -&gt; List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]]
</code></pre>

<p>Returns a list of vector transformations.</p>
<p>Each returned transformation is a function that transforms a
vector into a vector. The returned list always contains at least
one transformation: the identity function.  The transformations
returned are all transformations satisfying the given constraints.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>allow_rotations (bool)</strong>: Whether rotation is an allowed
    transformation.</li>
<li><strong>allow_reflections (bool)</strong>: Whether reflection is an allowed
    transformation.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Callable[[Vector], Vector]])</code>: A list of vector
    transformations.</p>
<h3 id="grilops.geometry.Lattice.get_inside_outside_check_directions">get_inside_outside_check_directions</h3>

<pre><code class="python">Lattice.get_inside_outside_check_directions(self) -&gt; Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]]
</code></pre>

<p>Returns directions for use in a loop inside-outside check.</p>
<p>The first direction returned is the direction to look, and the
remaining directions are the directions to check for crossings.</p>
<p>For instance, on a rectangular grid, a valid return value would
be (Vector(0, -1), [Vector(-1, 0)]).  This means that if you look
north and count how many west-going lines you cross, you can
tell from its parity if you're inside or outside the loop.</p>
<p><strong>Returns</strong></p>
<p><code>(Tuple[Vector, List[Vector]])</code>: A tuple, the first component of
    which indicates the direction to look and the second component
    of which indicates what types of crossing to count.</p>
<h3 id="grilops.geometry.Lattice.print">print</h3>

<pre><code class="python">Lattice.print(self, hook_function:Callable[[grilops.geometry.Point], str], blank:str=' ', stream:IO[str]=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;)
</code></pre>

<p>Prints something for each space in the lattice.</p>
<p>Printing is done from top to bottom and left to right.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>hook_function (Callable[[Point], str])</strong>: A function implementing
    per-location display behavior.  It will be called for each
    point in the lattice.  If the returned string has embedded
    newlines, it will be treated as a multi-line element.
    For best results, all elements should have the same number
    of lines as each other and as blank (below).</li>
<li><strong>blank (str)</strong>: What to print for points not in the lattice, or for
    when the hook function returns None. Defaults to one space.
    If it has embedded newlines, it will be treated as a
    multi-line element.</li>
<li><strong>stream (IO[str])</strong>: The stream to which to print the output. Defaults
    to standard output.</li>
</ul>
<h2 id="grilops.geometry.RectangularLattice">RectangularLattice</h2>

<pre><code class="python">RectangularLattice(self, points:List[grilops.geometry.Point])
</code></pre>

<p>A set of points corresponding to a rectangular lattice.</p>
<p>Note that these points need not fill a complete rectangle.</p>
<h3 id="grilops.geometry.RectangularLattice.points">points</h3>

<p>(List[Point]): The points in the lattice, sorted.
<h3 id="grilops.geometry.RectangularLattice.point_to_index">point_to_index</h3></p>
<pre><code class="python">RectangularLattice.point_to_index(self, point:grilops.geometry.Point) -&gt; Union[int, NoneType]
</code></pre>

<p>Returns the index of a point in the lattice's ordered list.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>point (Point)</strong>: The point to get the index of.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(Optional[int])</code>: The index of the point in the ordered list.
    None if the point is not in the list.</p>
<h3 id="grilops.geometry.RectangularLattice.edge_sharing_directions">edge_sharing_directions</h3>

<pre><code class="python">RectangularLattice.edge_sharing_directions(self) -&gt; List[Tuple[str, grilops.geometry.Vector]]
</code></pre>

<p>(List[Tuple[str, Vector]]): A list of edge-sharing directions.</p>
<p>Each entry in the returned list includes the name of an
edge-sharing direction and the vector representing that direction.
Edge sharing (also known as orthogonal adjacency) is the
relationship between grid cells that share an edge.</p>
<h3 id="grilops.geometry.RectangularLattice.vertex_sharing_directions">vertex_sharing_directions</h3>

<pre><code class="python">RectangularLattice.vertex_sharing_directions(self) -&gt; List[Tuple[str, grilops.geometry.Vector]]
</code></pre>

<p>(List[Tuple[str, Vector]]): A list of vertex-sharing directions.</p>
<p>Each entry in the returned list includes the name of a
vertex-sharing direction and the vector representing that
direction.  Vertex sharing (also known as touching adjacency) is
the relationship between grid cells that share a vertex.</p>
<h3 id="grilops.geometry.RectangularLattice.label_for_direction_pair">label_for_direction_pair</h3>

<pre><code class="python">RectangularLattice.label_for_direction_pair(self, d1:str, d2:str) -&gt; str
</code></pre>

<p>Returns the label for a pair of adjacency direction names.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>d1 (str)</strong>: The first direction's name (e.g., "N", "S", etc.)</li>
<li><strong>d2 (str)</strong>: The second direction's name.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(str)</code>: The label representing both directions.</p>
<p><strong>Raises</strong></p>
<ul>
<li><code>ValueError</code>: If there's no character defined for the direction pair.</li>
</ul>
<h3 id="grilops.geometry.RectangularLattice.transformation_functions">transformation_functions</h3>

<pre><code class="python">RectangularLattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -&gt; List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]]
</code></pre>

<p>Returns a list of vector transformations.</p>
<p>Each returned transformation is a function that transforms a
vector into a vector. The returned list always contains at least
one transformation: the identity function.  The transformations
returned are all transformations satisfying the given constraints.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>allow_rotations (bool)</strong>: Whether rotation is an allowed
    transformation.</li>
<li><strong>allow_reflections (bool)</strong>: Whether reflection is an allowed
    transformation.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Callable[[Vector], Vector]])</code>: A list of vector
    transformations.</p>
<h3 id="grilops.geometry.RectangularLattice.get_inside_outside_check_directions">get_inside_outside_check_directions</h3>

<pre><code class="python">RectangularLattice.get_inside_outside_check_directions(self) -&gt; Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]]
</code></pre>

<p>Returns directions for use in a loop inside-outside check.</p>
<p>The first direction returned is the direction to look, and the
remaining directions are the directions to check for crossings.</p>
<p>Since this is a rectangular grid, we return (Vector(0, -1),
[Vector(-1, 0)]).  This means that if you look north and count how
many west-going lines you cross, you can tell from its parity if
you're inside or outside the loop.</p>
<p><strong>Returns</strong></p>
<p><code>(Tuple[Vector, List[Vector]])</code>: A tuple, the first component of
    which indicates the direction to look and the second component
    of which indicates what types of crossing to count.</p>
<h2 id="grilops.geometry.FlatToppedHexagonalLattice">FlatToppedHexagonalLattice</h2>

<pre><code class="python">FlatToppedHexagonalLattice(self, points:List[grilops.geometry.Point])
</code></pre>

<p>A set of points forming a flat-topped hexagonal lattice.</p>
<p>All points must lie on a hexagonal lattice in which each hexagon has
a flat top.  We use the doubled coordinates scheme described at
https://www.redblobgames.com/grids/hexagons/.  That is, y describes
the row and x describes the column, so hexagons that are vertically
adjacent have their y coordinates differ by 2.</p>
<h3 id="grilops.geometry.FlatToppedHexagonalLattice.edge_sharing_directions">edge_sharing_directions</h3>

<pre><code class="python">FlatToppedHexagonalLattice.edge_sharing_directions(self) -&gt; List[Tuple[str, grilops.geometry.Vector]]
</code></pre>

<p>(List[Tuple[str, Vector]]): A list of edge-sharing directions.</p>
<p>Each entry in the returned list includes the name of an
edge-sharing direction and the vector representing that direction.
Edge sharing (also known as orthogonal adjacency) is the
relationship between grid cells that share an edge.</p>
<h3 id="grilops.geometry.FlatToppedHexagonalLattice.transformation_functions">transformation_functions</h3>

<pre><code class="python">FlatToppedHexagonalLattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -&gt; List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]]
</code></pre>

<p>Returns a list of vector transformations.</p>
<p>Each returned transformation is a function that transforms a
vector into a vector. The returned list always contains at least
one transformation: the identity function.  The transformations
returned are all transformations satisfying the given constraints.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>allow_rotations (bool)</strong>: Whether rotation is an allowed
    transformation.</li>
<li><strong>allow_reflections (bool)</strong>: Whether reflection is an allowed
    transformation.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Callable[[Vector], Vector]])</code>: A list of vector
    transformations.</p>
<h3 id="grilops.geometry.FlatToppedHexagonalLattice.get_inside_outside_check_directions">get_inside_outside_check_directions</h3>

<pre><code class="python">FlatToppedHexagonalLattice.get_inside_outside_check_directions(self) -&gt; Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]]
</code></pre>

<p>Returns directions for use in a loop inside-outside check.</p>
<p>The first direction returned is the direction to look, and the
remaining directions are the directions to check for crossings.</p>
<p>Since this is a flat-topped hexagonal grid, we return (Vector(-2,
0), [Vector(-1, -1), Vector(1, -1)]).  This means that if you look
north and count how many northwest-going and/or southwest-going
lines you cross, you can tell from its parity if you're inside or
outside the loop.</p>
<p><strong>Returns</strong></p>
<p><code>(Tuple[Vector, List[Vector]])</code>: A tuple, the first component of
    which indicates the direction to look and the second component
    of which indicates what types of crossing to count.</p>
<h2 id="grilops.geometry.PointyToppedHexagonalLattice">PointyToppedHexagonalLattice</h2>

<pre><code class="python">PointyToppedHexagonalLattice(self, points:List[grilops.geometry.Point])
</code></pre>

<p>A set of points forming a pointy-topped hexagonal lattice.</p>
<p>All points must lie on a hexagonal lattice in which each hexagon has
a pointy top.  We use the doubled coordinates scheme described at
https://www.redblobgames.com/grids/hexagons/.  That is, y describes
the row and x describes the column, so hexagons that are horizontally
adjacent have their x coordinates differ by 2.</p>
<h3 id="grilops.geometry.PointyToppedHexagonalLattice.edge_sharing_directions">edge_sharing_directions</h3>

<pre><code class="python">PointyToppedHexagonalLattice.edge_sharing_directions(self) -&gt; List[Tuple[str, grilops.geometry.Vector]]
</code></pre>

<p>(List[Tuple[str, Vector]]): A list of edge-sharing directions.</p>
<p>Each entry in the returned list includes the name of an
edge-sharing direction and the vector representing that direction.
Edge sharing (also known as orthogonal adjacency) is the
relationship between grid cells that share an edge.</p>
<h3 id="grilops.geometry.PointyToppedHexagonalLattice.transformation_functions">transformation_functions</h3>

<pre><code class="python">PointyToppedHexagonalLattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -&gt; List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]]
</code></pre>

<p>Returns a list of vector transformations.</p>
<p>Each returned transformation is a function that transforms a
vector into a vector. The returned list always contains at least
one transformation: the identity function.  The transformations
returned are all transformations satisfying the given constraints.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>allow_rotations (bool)</strong>: Whether rotation is an allowed
    transformation.</li>
<li><strong>allow_reflections (bool)</strong>: Whether reflection is an allowed
    transformation.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(List[Callable[[Vector], Vector]])</code>: A list of vector
    transformations.</p>
<h3 id="grilops.geometry.PointyToppedHexagonalLattice.get_inside_outside_check_directions">get_inside_outside_check_directions</h3>

<pre><code class="python">PointyToppedHexagonalLattice.get_inside_outside_check_directions(self) -&gt; Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]]
</code></pre>

<p>Returns directions for use in a loop inside-outside check.</p>
<p>The first direction returned is the direction to look, and the
remaining directions are the directions to check for crossings.</p>
<p>Since this is a pointy-topped hexagonal grid, we return
(Vector(0, 2), [Vector(-1, -1), Vector(-1, 1)]).  This means
that if you look east and count how many northwest-going
and/or northeast-going lines you cross, you can tell from
its parity if you're inside or outside the loop.</p>
<p><strong>Returns</strong></p>
<p><code>(Tuple[Vector, List[Vector]])</code>: A tuple, the first component of
    which indicates the direction to look and the second component
    of which indicates what types of crossing to count.</p>
<h2 id="grilops.geometry.get_rectangle_lattice">get_rectangle_lattice</h2>

<pre><code class="python">get_rectangle_lattice(height:int, width:int) -&gt; grilops.geometry.RectangularLattice
</code></pre>

<p>Returns a lattice of all points in a rectangle of the given dimensions.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>height (int)</strong>: Height of the lattice.</li>
<li><strong>width (int)</strong>: Width of the lattice.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(RectangularLattice)</code>: The lattice.</p>
<h2 id="grilops.geometry.get_square_lattice">get_square_lattice</h2>

<pre><code class="python">get_square_lattice(height:int) -&gt; grilops.geometry.RectangularLattice
</code></pre>

<p>Returns a lattice of all points in a square of the given height.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>height (int)</strong>: Height of the lattice.</li>
</ul>
<p><strong>Returns</strong></p>
<p><code>(RectangularLattice)</code>: The lattice.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../grids/" class="btn btn-neutral float-right" title="Grids">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../symbols/" class="btn btn-neutral" title="Symbols"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../symbols/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../grids/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
