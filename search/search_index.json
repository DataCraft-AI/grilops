{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"grilops a GRId LOgic Puzzle Solver library, using Python 3 and z3 . This package contains a collection of libraries and helper functions that are useful for solving and checking Nikoli -style logic puzzles using z3. To get a feel for how to use this package to model and solve puzzles, try working through the tutorial IPython notebook , and refer to the examples and the API Documentation . Installation grilops requires Python 3.6 or later. To install grilops for use in your own programs: $ pip3 install grilops To install the source code (to run the examples and/or work with the code): $ git clone https://github.com/obijywk/grilops.git $ cd grilops $ pip3 install -e . Basic Concepts and Usage The symbols , geometry , and grids modules contain the core functionality needed for modeling most puzzles. For convenience, their attributes can be accessed directly from the top-level grilops module. Symbols represent the marks that are determined and written into a grid by a solver while solving a puzzle. For example, the symbol set of a Sudoku puzzle would be the digits 1 through 9. The symbol set of a binary determination puzzle such as Nurikabe could contain two symbols, one representing a black cell and the other representing a white cell. The geometry module defines Lattice classes that are used to manage the shapes of grids and relationships between cells. Rectangular and hexagonal grids are supported, as well as grids with empty spaces in them. A symbol grid is used to keep track of the assignment of symbols to grid cells. Generally, setting up a program to solve a puzzle using grilops involves: Constructing a symbol set Constructing a lattice for the grid Constructing a symbol grid in the shape of the lattice, limited to contain symbols from the symbol set Adding puzzle-specific constraints to cells in the symbol grid Checking for satisfying assignments of symbols to symbol grid cells Grid cells are exposed as z3 constants, so built-in z3 operators can and should be used when adding puzzle-specific constraints. In addition, grilops provides several modules to help automate and abstract away the introduction of common kinds of constraints. Loops The grilops.loops module is helpful for adding constraints that ensure symbols connect to form closed loops. Some examples of puzzle types for which this is useful are Masyu and Slitherlink . $ python3 examples/masyu.py $ python3 examples/slitherlink.py \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2510 \u250c\u2500\u2500\u2510 \u250c\u2518 \u250c\u2500\u2518\u2514\u2500\u2510\u2502 \u2502\u250c\u2510\u2502 \u250c\u2510 \u2514\u2500\u2510\u2502\u250c\u2500\u2500\u2510\u2502\u2502 \u2514\u2518\u2502\u2514\u2510\u2502\u2502 \u2502\u2502\u2502\u250c\u2500\u2518\u2502\u2502 \u2502 \u2514\u2518\u2502 \u250c\u2500\u2518\u2514\u2518\u2502 \u250c\u2518\u2502 \u2514\u2510 \u2502 \u2502\u250c\u2500\u2500\u2510\u2502 \u2502\u250c\u2518 \u250c\u2500\u2500\u2518\u250c\u2510\u2502 \u2502\u2502\u250c\u2500\u2518\u2514\u2500\u2518\u2514\u2510 \u2514\u2500\u2500\u2500\u2518\u2514\u2518 \u2502\u2502\u2502 \u250c\u2500\u2500\u2500\u2510\u2502 \u2514\u2518\u2502 \u2502\u250c\u2500\u2500\u2518\u2502 Unique solution \u2514\u2500\u2518\u2514\u2500\u2500\u2500\u2518 Unique solution Regions The grilops.regions module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of variable shapes and sizes. Some examples of puzzle types for which this is useful are Nurikabe and Fillomino . $ python3 examples/nurikabe.py $ python3 examples/fillomino.py 2 \u2588 \u2588\u2588 2 8 8 3 3 101010105 \u2588\u2588\u2588 \u25882\u2588\u2588\u2588 8 8 8 3 1010105 5 \u25882\u2588 7\u2588 \u2588 \u2588 3 3 8 10104 4 4 5 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588 1 3 8 3 102 2 4 5 \u2588\u2588 \u2588 3\u25883\u2588 2 2 8 3 3 1 3 2 2 \u25882\u2588\u2588\u2588\u25883\u2588\u2588 6 6 2 2 1 3 3 1 3 2\u2588\u25884 \u2588 \u2588 6 4 4 4 2 2 1 3 3 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 6 4 2 2 4 3 3 4 4 \u25881\u2588\u2588\u2588 2\u25884 6 6 4 4 4 1 3 4 4 Unique solution Unique solution Shapes The grilops.shapes module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of fixed shapes and sizes. Some examples of puzzle types for which this is useful are Battleship and LITS . $ python3 examples/battleship.py $ python3 examples/lits.py \u25b4 IIII \u25c2\u25aa\u25b8 \u25aa \u2022 SS L \u25be LSS L I \u25c2\u25aa\u25aa\u25b8 \u2022 L IIIILLI LL L I \u25b4 \u25c2\u25b8 TTT L I \u25be \u25b4 SS T LL T \u25be \u2022 SSLL TT L T T Unique solution IIIILTTT Unique solution Sightlines The grilops.sightlines module is helpful for adding constraints that ensure properties hold along straight lines through the grid. These \"sightlines\" may terminate before reaching the edge of the grid if certain conditions are met (e.g. if a certain symbol, such as one representing a wall, is encountered). Some examples of puzzle types for which this is useful are Akari and Skyscraper . $ python3 examples/akari.py $ python3 examples/skyscraper.py \u2588* \u2588* \u2588 23541 * \u2588 15432 *\u2588* \u2588 * 34215 *\u2588 \u2588 \u2588 42153 \u2588\u2588\u2588* 51324 *\u2588\u2588\u2588* \u2588 * \u2588* \u2588* Unique solution * \u2588* \u2588* \u2588 * \u2588 * \u2588* \u2588 Unique solution","title":"Home"},{"location":"#grilops","text":"a GRId LOgic Puzzle Solver library, using Python 3 and z3 . This package contains a collection of libraries and helper functions that are useful for solving and checking Nikoli -style logic puzzles using z3. To get a feel for how to use this package to model and solve puzzles, try working through the tutorial IPython notebook , and refer to the examples and the API Documentation .","title":"grilops"},{"location":"#installation","text":"grilops requires Python 3.6 or later. To install grilops for use in your own programs: $ pip3 install grilops To install the source code (to run the examples and/or work with the code): $ git clone https://github.com/obijywk/grilops.git $ cd grilops $ pip3 install -e .","title":"Installation"},{"location":"#basic-concepts-and-usage","text":"The symbols , geometry , and grids modules contain the core functionality needed for modeling most puzzles. For convenience, their attributes can be accessed directly from the top-level grilops module. Symbols represent the marks that are determined and written into a grid by a solver while solving a puzzle. For example, the symbol set of a Sudoku puzzle would be the digits 1 through 9. The symbol set of a binary determination puzzle such as Nurikabe could contain two symbols, one representing a black cell and the other representing a white cell. The geometry module defines Lattice classes that are used to manage the shapes of grids and relationships between cells. Rectangular and hexagonal grids are supported, as well as grids with empty spaces in them. A symbol grid is used to keep track of the assignment of symbols to grid cells. Generally, setting up a program to solve a puzzle using grilops involves: Constructing a symbol set Constructing a lattice for the grid Constructing a symbol grid in the shape of the lattice, limited to contain symbols from the symbol set Adding puzzle-specific constraints to cells in the symbol grid Checking for satisfying assignments of symbols to symbol grid cells Grid cells are exposed as z3 constants, so built-in z3 operators can and should be used when adding puzzle-specific constraints. In addition, grilops provides several modules to help automate and abstract away the introduction of common kinds of constraints.","title":"Basic Concepts and Usage"},{"location":"#loops","text":"The grilops.loops module is helpful for adding constraints that ensure symbols connect to form closed loops. Some examples of puzzle types for which this is useful are Masyu and Slitherlink . $ python3 examples/masyu.py $ python3 examples/slitherlink.py \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2510 \u250c\u2500\u2500\u2510 \u250c\u2518 \u250c\u2500\u2518\u2514\u2500\u2510\u2502 \u2502\u250c\u2510\u2502 \u250c\u2510 \u2514\u2500\u2510\u2502\u250c\u2500\u2500\u2510\u2502\u2502 \u2514\u2518\u2502\u2514\u2510\u2502\u2502 \u2502\u2502\u2502\u250c\u2500\u2518\u2502\u2502 \u2502 \u2514\u2518\u2502 \u250c\u2500\u2518\u2514\u2518\u2502 \u250c\u2518\u2502 \u2514\u2510 \u2502 \u2502\u250c\u2500\u2500\u2510\u2502 \u2502\u250c\u2518 \u250c\u2500\u2500\u2518\u250c\u2510\u2502 \u2502\u2502\u250c\u2500\u2518\u2514\u2500\u2518\u2514\u2510 \u2514\u2500\u2500\u2500\u2518\u2514\u2518 \u2502\u2502\u2502 \u250c\u2500\u2500\u2500\u2510\u2502 \u2514\u2518\u2502 \u2502\u250c\u2500\u2500\u2518\u2502 Unique solution \u2514\u2500\u2518\u2514\u2500\u2500\u2500\u2518 Unique solution","title":"Loops"},{"location":"#regions","text":"The grilops.regions module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of variable shapes and sizes. Some examples of puzzle types for which this is useful are Nurikabe and Fillomino . $ python3 examples/nurikabe.py $ python3 examples/fillomino.py 2 \u2588 \u2588\u2588 2 8 8 3 3 101010105 \u2588\u2588\u2588 \u25882\u2588\u2588\u2588 8 8 8 3 1010105 5 \u25882\u2588 7\u2588 \u2588 \u2588 3 3 8 10104 4 4 5 \u2588 \u2588\u2588\u2588\u2588\u2588\u2588 \u2588 1 3 8 3 102 2 4 5 \u2588\u2588 \u2588 3\u25883\u2588 2 2 8 3 3 1 3 2 2 \u25882\u2588\u2588\u2588\u25883\u2588\u2588 6 6 2 2 1 3 3 1 3 2\u2588\u25884 \u2588 \u2588 6 4 4 4 2 2 1 3 3 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588 6 4 2 2 4 3 3 4 4 \u25881\u2588\u2588\u2588 2\u25884 6 6 4 4 4 1 3 4 4 Unique solution Unique solution","title":"Regions"},{"location":"#shapes","text":"The grilops.shapes module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of fixed shapes and sizes. Some examples of puzzle types for which this is useful are Battleship and LITS . $ python3 examples/battleship.py $ python3 examples/lits.py \u25b4 IIII \u25c2\u25aa\u25b8 \u25aa \u2022 SS L \u25be LSS L I \u25c2\u25aa\u25aa\u25b8 \u2022 L IIIILLI LL L I \u25b4 \u25c2\u25b8 TTT L I \u25be \u25b4 SS T LL T \u25be \u2022 SSLL TT L T T Unique solution IIIILTTT Unique solution","title":"Shapes"},{"location":"#sightlines","text":"The grilops.sightlines module is helpful for adding constraints that ensure properties hold along straight lines through the grid. These \"sightlines\" may terminate before reaching the edge of the grid if certain conditions are met (e.g. if a certain symbol, such as one representing a wall, is encountered). Some examples of puzzle types for which this is useful are Akari and Skyscraper . $ python3 examples/akari.py $ python3 examples/skyscraper.py \u2588* \u2588* \u2588 23541 * \u2588 15432 *\u2588* \u2588 * 34215 *\u2588 \u2588 \u2588 42153 \u2588\u2588\u2588* 51324 *\u2588\u2588\u2588* \u2588 * \u2588* \u2588* Unique solution * \u2588* \u2588* \u2588 * \u2588 * \u2588* \u2588 Unique solution","title":"Sightlines"},{"location":"geometry/","text":"grilops.geometry This module supports geometric objects useful in modeling grids of cells. Vector Vector(self, /, *args, **kwargs) A vector representing an offset in two dimensions. Attributes dy (int) : The relative distance in the y dimension. dx (int) : The relative distance in the x dimension. dx Alias for field number 1 dy Alias for field number 0 negate Vector.negate(self) -> 'Vector' Returns a vector that's the negation of this one. translate Vector.translate(self, d:'Vector') -> 'Vector' Translates this vector's endpoint in the given direction. Point Point(self, /, *args, **kwargs) A point, generally corresponding to the center of a grid cell. Attributes y (int) : The location in the y dimension. x (int) : The location in the x dimension. x Alias for field number 1 y Alias for field number 0 translate Point.translate(self, d:grilops.geometry.Vector) -> 'Point' Translates this point in the given direction. Neighbor Neighbor(self, /, *args, **kwargs) Properties of a cell that is a neighbor of another. Attributes location (Point) : The location of the cell. direction (Vector) : The direction from the original cell. symbol (z3.ArithRef) : The symbol constant of the cell. direction Alias for field number 1 location Alias for field number 0 symbol Alias for field number 2 Lattice Lattice(self, /, *args, **kwargs) A set of points corresponding to a lattice. points (List[Point]): The points in the lattice, sorted. point_to_index Lattice.point_to_index(self, point:grilops.geometry.Point) -> Union[int, NoneType] Returns the index of a point in the lattice's ordered list. Arguments point (Point) : The point to get the index of. Returns (Optional[int]) : The index of the point in the ordered list. None if the point is not in the list. edge_sharing_directions Lattice.edge_sharing_directions(self) -> List[Tuple[str, grilops.geometry.Vector]] (List[Tuple[str, Vector]]): A list of edge-sharing directions. Each entry in the returned list includes the name of an edge-sharing direction and the vector representing that direction. Edge sharing (also known as orthogonal adjacency) is the relationship between grid cells that share an edge. vertex_sharing_directions Lattice.vertex_sharing_directions(self) -> List[Tuple[str, grilops.geometry.Vector]] (List[Tuple[str, Vector]]): A list of vertex-sharing directions. Each entry in the returned list includes the name of a vertex-sharing direction and the vector representing that direction. Vertex sharing (also known as touching adjacency) is the relationship between grid cells that share a vertex. edge_sharing_points Lattice.edge_sharing_points(self, point:grilops.geometry.Point) -> List[grilops.geometry.Point] Returns the points that share an edge with the given cell. Arguments point (Point) : The point of the given cell. Returns (List[Point]) : A list of points in the lattice that correspond to cells that share an edge with the given cell. vertex_sharing_points Lattice.vertex_sharing_points(self, point:grilops.geometry.Point) -> List[grilops.geometry.Point] Returns a list of points sharing a vertex with the given cell. Arguments point (Point) : The point of the given cell. Returns (List[Point]) : A list of points in the lattice corresponding to cells that share a vertex with the given cell. edge_sharing_neighbors Lattice.edge_sharing_neighbors(self, cell_map:Dict[grilops.geometry.Point, z3.z3.ArithRef], p:grilops.geometry.Point) -> List[grilops.geometry.Neighbor] Returns a list of neighbors sharing an edge with the given cell. Arguments cell_map (Dict[Point, ArithRef]) : A dictionary mapping points in the lattice to z3 constants. p (Point) : Point of the given cell. Returns (List[Neighbor]) : The neighbor structures corresponding to the cells that share an edge with the given cell. vertex_sharing_neighbors Lattice.vertex_sharing_neighbors(self, cell_map:Dict[grilops.geometry.Point, z3.z3.ArithRef], p:grilops.geometry.Point) -> List[grilops.geometry.Neighbor] Returns a list of neighbors sharing a vertex with the given cell. Arguments cell_map (Dict[Point, ArithRef]) : A dictionary mapping points in the lattice to z3 constants. p (Point) : Point of the given cell. Returns (List[Neighbor]) : The neighbor structures corresponding to the cells that share a vertex with the given cell. label_for_direction_pair Lattice.label_for_direction_pair(self, d1:str, d2:str) -> str Returns the label for a pair of edge-sharing direction names. Arguments d1 (str) : The first direction (e.g., \"N\", \"S\", etc.) d2 (str) : The second direction. Returns (str) : The label representing both directions. transformation_functions Lattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -> List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]] Returns a list of vector transformations. Each returned transformation is a function that transforms a vector into a vector. The returned list always contains at least one transformation: the identity function. The transformations returned are all transformations satisfying the given constraints. Arguments allow_rotations (bool) : Whether rotation is an allowed transformation. allow_reflections (bool) : Whether reflection is an allowed transformation. Returns (List[Callable[[Vector], Vector]]) : A list of vector transformations. get_inside_outside_check_directions Lattice.get_inside_outside_check_directions(self) -> Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]] Returns directions for use in a loop inside-outside check. The first direction returned is the direction to look, and the remaining directions are the directions to check for crossings. For instance, on a rectangular grid, a valid return value would be (Vector(0, -1), [Vector(-1, 0)]). This means that if you look north and count how many west-going lines you cross, you can tell from its parity if you're inside or outside the loop. Returns (Tuple[Vector, List[Vector]]) : A tuple, the first component of which indicates the direction to look and the second component of which indicates what types of crossing to count. print Lattice.print(self, hook_function:Callable[[grilops.geometry.Point], str], blank:str=' ', stream:IO[str]=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>) Prints something for each space in the lattice. Printing is done from top to bottom and left to right. Arguments hook_function (Callable[[Point], str]) : A function implementing per-location display behavior. It will be called for each point in the lattice. If the returned string has embedded newlines, it will be treated as a multi-line element. For best results, all elements should have the same number of lines as each other and as blank (below). blank (str) : What to print for points not in the lattice, or for when the hook function returns None. Defaults to one space. If it has embedded newlines, it will be treated as a multi-line element. stream (IO[str]) : The stream to which to print the output. Defaults to standard output. RectangularLattice RectangularLattice(self, points:List[grilops.geometry.Point]) A set of points corresponding to a rectangular lattice. Note that these points need not fill a complete rectangle. points (List[Point]): The points in the lattice, sorted. point_to_index RectangularLattice.point_to_index(self, point:grilops.geometry.Point) -> Union[int, NoneType] Returns the index of a point in the lattice's ordered list. Arguments point (Point) : The point to get the index of. Returns (Optional[int]) : The index of the point in the ordered list. None if the point is not in the list. edge_sharing_directions RectangularLattice.edge_sharing_directions(self) -> List[Tuple[str, grilops.geometry.Vector]] (List[Tuple[str, Vector]]): A list of edge-sharing directions. Each entry in the returned list includes the name of an edge-sharing direction and the vector representing that direction. Edge sharing (also known as orthogonal adjacency) is the relationship between grid cells that share an edge. vertex_sharing_directions RectangularLattice.vertex_sharing_directions(self) -> List[Tuple[str, grilops.geometry.Vector]] (List[Tuple[str, Vector]]): A list of vertex-sharing directions. Each entry in the returned list includes the name of a vertex-sharing direction and the vector representing that direction. Vertex sharing (also known as touching adjacency) is the relationship between grid cells that share a vertex. label_for_direction_pair RectangularLattice.label_for_direction_pair(self, d1:str, d2:str) -> str Returns the label for a pair of adjacency direction names. Arguments d1 (str) : The first direction's name (e.g., \"N\", \"S\", etc.) d2 (str) : The second direction's name. Returns (str) : The label representing both directions. Raises ValueError : If there's no character defined for the direction pair. transformation_functions RectangularLattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -> List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]] Returns a list of vector transformations. Each returned transformation is a function that transforms a vector into a vector. The returned list always contains at least one transformation: the identity function. The transformations returned are all transformations satisfying the given constraints. Arguments allow_rotations (bool) : Whether rotation is an allowed transformation. allow_reflections (bool) : Whether reflection is an allowed transformation. Returns (List[Callable[[Vector], Vector]]) : A list of vector transformations. get_inside_outside_check_directions RectangularLattice.get_inside_outside_check_directions(self) -> Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]] Returns directions for use in a loop inside-outside check. The first direction returned is the direction to look, and the remaining directions are the directions to check for crossings. Since this is a rectangular grid, we return (Vector(0, -1), [Vector(-1, 0)]). This means that if you look north and count how many west-going lines you cross, you can tell from its parity if you're inside or outside the loop. Returns (Tuple[Vector, List[Vector]]) : A tuple, the first component of which indicates the direction to look and the second component of which indicates what types of crossing to count. FlatToppedHexagonalLattice FlatToppedHexagonalLattice(self, points:List[grilops.geometry.Point]) A set of points forming a flat-topped hexagonal lattice. All points must lie on a hexagonal lattice in which each hexagon has a flat top. We use the doubled coordinates scheme described at https://www.redblobgames.com/grids/hexagons/. That is, y describes the row and x describes the column, so hexagons that are vertically adjacent have their y coordinates differ by 2. edge_sharing_directions FlatToppedHexagonalLattice.edge_sharing_directions(self) -> List[Tuple[str, grilops.geometry.Vector]] (List[Tuple[str, Vector]]): A list of edge-sharing directions. Each entry in the returned list includes the name of an edge-sharing direction and the vector representing that direction. Edge sharing (also known as orthogonal adjacency) is the relationship between grid cells that share an edge. transformation_functions FlatToppedHexagonalLattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -> List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]] Returns a list of vector transformations. Each returned transformation is a function that transforms a vector into a vector. The returned list always contains at least one transformation: the identity function. The transformations returned are all transformations satisfying the given constraints. Arguments allow_rotations (bool) : Whether rotation is an allowed transformation. allow_reflections (bool) : Whether reflection is an allowed transformation. Returns (List[Callable[[Vector], Vector]]) : A list of vector transformations. get_inside_outside_check_directions FlatToppedHexagonalLattice.get_inside_outside_check_directions(self) -> Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]] Returns directions for use in a loop inside-outside check. The first direction returned is the direction to look, and the remaining directions are the directions to check for crossings. Since this is a flat-topped hexagonal grid, we return (Vector(-2, 0), [Vector(-1, -1), Vector(1, -1)]). This means that if you look north and count how many northwest-going and/or southwest-going lines you cross, you can tell from its parity if you're inside or outside the loop. Returns (Tuple[Vector, List[Vector]]) : A tuple, the first component of which indicates the direction to look and the second component of which indicates what types of crossing to count. PointyToppedHexagonalLattice PointyToppedHexagonalLattice(self, points:List[grilops.geometry.Point]) A set of points forming a pointy-topped hexagonal lattice. All points must lie on a hexagonal lattice in which each hexagon has a pointy top. We use the doubled coordinates scheme described at https://www.redblobgames.com/grids/hexagons/. That is, y describes the row and x describes the column, so hexagons that are horizontally adjacent have their x coordinates differ by 2. edge_sharing_directions PointyToppedHexagonalLattice.edge_sharing_directions(self) -> List[Tuple[str, grilops.geometry.Vector]] (List[Tuple[str, Vector]]): A list of edge-sharing directions. Each entry in the returned list includes the name of an edge-sharing direction and the vector representing that direction. Edge sharing (also known as orthogonal adjacency) is the relationship between grid cells that share an edge. transformation_functions PointyToppedHexagonalLattice.transformation_functions(self, allow_rotations:bool, allow_reflections:bool) -> List[Callable[[grilops.geometry.Vector], grilops.geometry.Vector]] Returns a list of vector transformations. Each returned transformation is a function that transforms a vector into a vector. The returned list always contains at least one transformation: the identity function. The transformations returned are all transformations satisfying the given constraints. Arguments allow_rotations (bool) : Whether rotation is an allowed transformation. allow_reflections (bool) : Whether reflection is an allowed transformation. Returns (List[Callable[[Vector], Vector]]) : A list of vector transformations. get_inside_outside_check_directions PointyToppedHexagonalLattice.get_inside_outside_check_directions(self) -> Tuple[grilops.geometry.Vector, List[grilops.geometry.Vector]] Returns directions for use in a loop inside-outside check. The first direction returned is the direction to look, and the remaining directions are the directions to check for crossings. Since this is a pointy-topped hexagonal grid, we return (Vector(0, 2), [Vector(-1, -1), Vector(-1, 1)]). This means that if you look east and count how many northwest-going and/or northeast-going lines you cross, you can tell from its parity if you're inside or outside the loop. Returns (Tuple[Vector, List[Vector]]) : A tuple, the first component of which indicates the direction to look and the second component of which indicates what types of crossing to count. get_rectangle_lattice get_rectangle_lattice(height:int, width:int) -> grilops.geometry.RectangularLattice Returns a lattice of all points in a rectangle of the given dimensions. Arguments height (int) : Height of the lattice. width (int) : Width of the lattice. Returns (RectangularLattice) : The lattice. get_square_lattice get_square_lattice(height:int) -> grilops.geometry.RectangularLattice Returns a lattice of all points in a square of the given height. Arguments height (int) : Height of the lattice. Returns (RectangularLattice) : The lattice.","title":"Geometry"},{"location":"grids/","text":"grilops.grids This module supports constructing and working with grids of cells. SymbolGrid SymbolGrid(self, lattice:grilops.geometry.Lattice, symbol_set:grilops.symbols.SymbolSet, solver:z3.z3.Solver=None) A grid of cells that can be solved to contain specific symbols. Arguments lattice (Lattice) : The structure of the grid. symbol_set (SymbolSet) : The set of symbols to be filled into the grid. solver (z3.Solver, None) : A Solver object. If None, a Solver will be constructed. grid (Dict[Point, ArithRef]): The grid of cells. lattice (Lattice): The lattice of points in the grid. solver (z3.Solver): The Solver object associated with this SymbolGrid . symbol_set (SymbolSet): The SymbolSet associated with this SymbolGrid . edge_sharing_neighbors SymbolGrid.edge_sharing_neighbors(self, p:grilops.geometry.Point) -> List[grilops.geometry.Neighbor] Returns a list of cells that share an edge with the given cell. Arguments p : Location of the given cell. Returns (List[Neighbor]) : The cells sharing an edge with the given cell. vertex_sharing_neighbors SymbolGrid.vertex_sharing_neighbors(self, p:grilops.geometry.Point) -> List[grilops.geometry.Neighbor] Returns the cells that share a vertex with the given cell. In other words, returns a list of cells orthogonally and diagonally adjacent to the given cell. Arguments p : Location of the given cell. Returns (List[Neighbor]) : The cells sharing a vertex with the given cell. cell_is SymbolGrid.cell_is(self, p:grilops.geometry.Point, value:int) -> z3.z3.BoolRef Returns an expression for whether this cell contains this value. Arguments p : The location of the given cell in the grid. value (int) : The value to satisfy the expression. Returns (z3.BoolRef) : an expression that's true if and only if the cell at p contains this value. cell_is_one_of SymbolGrid.cell_is_one_of(self, p:grilops.geometry.Point, values:List[int]) -> z3.z3.BoolRef Returns an expression for whether this cell contains one of these values. Arguments p : The location of the given cell in the grid. values (list(int)) : The list of values to satisfy the expression. Returns (z3.BoolRef) : an expression that's true if and only if the cell at p contains one of the values. solve SymbolGrid.solve(self) -> bool Returns true if the puzzle has a solution, false otherwise. is_unique SymbolGrid.is_unique(self) -> bool Returns true if the solution to the puzzle is unique, false otherwise. Should be called only after SymbolGrid.solve() has already completed successfully. solved_grid SymbolGrid.solved_grid(self) -> Dict[grilops.geometry.Point, int] Returns the solved symbol grid. Should be called only after SymbolGrid.solve() has already completed successfully. print SymbolGrid.print(self, hook_function:Callable[[grilops.geometry.Point, int], str]=None) Prints the solved grid using symbol labels. Should be called only after SymbolGrid.solve() has already completed successfully. Arguments hook_function (function, None) : A function implementing custom symbol display behavior, or None. If this function is provided, it will be called for each cell in the grid, with the arguments p (Point) and the symbol index for that cell (int). It may return a string to print for that cell, or None to keep the default behavior.","title":"Grids"},{"location":"loops/","text":"grilops.loops This module supports puzzles where closed loops are filled into a grid. Attributes L (int) : The LoopConstrainer.inside_outside_grid value indicating that a cell contains part of a loop. I (int) : The LoopConstrainer.inside_outside_grid value indicating that a cell is inside of a loop. O (int) : The LoopConstrainer.inside_outside_grid value indicating that a cell is outside of a loop. LoopSymbolSet LoopSymbolSet(self, lattice:grilops.geometry.Lattice) A SymbolSet consisting of symbols that may form loops. Additional symbols (e.g. a Symbol representing an empty space) may be added to this SymbolSet by calling SymbolSet.append() after it's constructed. is_loop LoopSymbolSet.is_loop(self, symbol:z3.z3.ArithRef) -> z3.z3.BoolRef Returns true if symbol represents part of the loop. Arguments symbol (z3.ArithRef) : A z3 expression representing a symbol. Returns (z3.BoolRef) : true if the symbol represents part of the loop. symbols_for_direction LoopSymbolSet.symbols_for_direction(self, d:grilops.geometry.Vector) -> List[int] Returns the symbols with one arm going in the given direction. Arguments d (Vector) : The given direction. Returns (List[int]) : A list of symbol indices corresponding to symbols with one arm going in the given direction. symbol_for_direction_pair LoopSymbolSet.symbol_for_direction_pair(self, d1:grilops.geometry.Vector, d2:grilops.geometry.Vector) -> int Returns the symbol with arms going in the two given directions. Arguments d1 (Vector) : The first given direction. d2 (Vector) : The second given direction. Returns (int) : The symbol index for the symbol with one arm going in each of the two given directions. LoopConstrainer LoopConstrainer(self, symbol_grid:grilops.grids.SymbolGrid, single_loop:bool=False) Creates constraints for ensuring symbols form closed loops. Arguments symbol_grid (SymbolGrid) : The SymbolGrid to constrain. single_loop (bool) : If true, constrain the grid to contain only a single loop. inside_outside_grid (Dict[Point, ArithRef]): Whether cells are contained by loops. Values are the L, I, and O attributes of this module. loop_order_grid (Dict[Point, ArithRef]): Constants of a loop traversal order. Only populated if single_loop was true. print_inside_outside_grid LoopConstrainer.print_inside_outside_grid(self) Prints which cells are contained by loops.","title":"Loops"},{"location":"regions/","text":"grilops.regions This module supports puzzles that group cells into contiguous regions. Internally, the RegionConstrainer constructs subtrees, each spanning the cells contained within a region. Aspects of a cell's relationship to the other cells in its subtree are exposed by properties of the RegionConstrainer . Attributes X (int) : The RegionConstrainer.parent_grid value indicating that a cell is not part of a region. R (int) : The RegionConstrainer.parent_grid value indicating that a cell is the root of its region's subtree. RegionConstrainer RegionConstrainer(self, lattice:grilops.geometry.Lattice, solver:z3.z3.Solver=None, complete:bool=True, min_region_size:Union[int, NoneType]=None, max_region_size:Union[int, NoneType]=None) Creates constraints for grouping cells into contiguous regions. Arguments lattice (Lattice) : The structure of the grid. solver (z3.Solver, None) : A Solver object. If None, a Solver will be constructed. complete (bool) : If true, every cell must be part of a region. Defaults to true. min_region_size(int, None) : The minimum possible size of a region. max_region_size(int, None) : The maximum possible size of a region. parent_grid (Dict[Point, ArithRef]): A dictionary of region subtree parent pointers. region_id_grid (Dict[Point, ArithRef]): A dictionary of numbers identifying regions. A region's identifier is the position in the grid (going in order from left to right, top to bottom) of the root of that region's subtree. It is the same as the index of the point in the lattice. region_size_grid (Dict[Point, ArithRef]): A dictionary of region sizes. solver (z3.Solver): The Solver associated with this RegionConstrainer . subtree_size_grid (Dict[Point, ArithRef]): A dictionary of cell subtree sizes. A cell's subtree size is one plus the number of cells that are descendents of the cell in its region's subtree. edge_sharing_direction_to_index RegionConstrainer.edge_sharing_direction_to_index(self, direction:grilops.geometry.Vector) -> int Returns the parent_grid value corresponding to the given direction. For instance, if direction is (-1, 0), return the index for N. Arguments direction (Vector) : The direction to an edge-sharing cell. Returns (int) : The parent_grid value that means that the parent in its region's subtree is the cell offset by that direction. parent_type_to_index RegionConstrainer.parent_type_to_index(self, parent_type:str) -> int Returns the parent_grid value corresponding to the given parent type. Arguments parent_type (str) : The parent type. Returns (int) : The corresponding parent_grid value. print_trees RegionConstrainer.print_trees(self) Prints the region parent assigned to each cell. Should be called only after the solver has been checked. print_subtree_sizes RegionConstrainer.print_subtree_sizes(self) Prints the region subtree size of each cell. Should be called only after the solver has been checked. print_region_ids RegionConstrainer.print_region_ids(self) Prints a number identifying the region that owns each cell. Should be called only after the solver has been checked. print_region_sizes RegionConstrainer.print_region_sizes(self) Prints the size of the region that contains each cell. Should be called only after the solver has been checked.","title":"Regions"},{"location":"shapes/","text":"grilops.shapes This module supports puzzles that place fixed shape regions into the grid. canonicalize_shape canonicalize_shape(shape:List[grilops.geometry.Vector]) -> List[grilops.geometry.Vector] Returns a new shape that's canonicalized. A canonicalized shape is in sorted order and its first offset is Vector(0, 0). This helps with deduplication, since equivalent shapes will be canonicalized identically. Arguments shape (List[Vector]) : A list of offsets defining a shape. Returns (List[Vector]) : A list of offsets defining the canonicalized version of the shape, i.e., in sorted order and with first offset equal to Vector(0, 0). ShapeConstrainer ShapeConstrainer(self, lattice:grilops.geometry.Lattice, shapes:List[List[grilops.geometry.Vector]], solver:z3.z3.Solver=None, complete:bool=False, allow_rotations:bool=False, allow_reflections:bool=False, allow_copies:bool=False) Creates constraints for placing fixed shape regions into the grid. Arguments lattice (Lattice) : The structure of the grid. shapes (List[List[Vector]]) : A list of region shape definitions. Each region shape definition should be a list of offsets. The same region shape definition may be included multiple times to indicate the number of times that shape may appear (if allow_copies is false). solver (z3.Solver, None) : A Solver object. If None, a Solver will be constructed. complete (bool) : If true, every cell must be part of a shape region. Defaults to false. allow_rotations (bool) : If true, allow rotations of the shapes to be placed in the grid. Defaults to false. allow_reflections (bool) : If true, allow reflections of the shapes to be placed in the grid. Defaults to false. allow_copies (bool) : If true, allow any number of copies of the shapes to be placed in the grid. Defaults to false. shape_instance_grid (Dict[Point, ArithRef]): z3 constants of shape instance IDs. Each cell contains a number shared among all cells containing the same instance of the shape, or -1 if no shape is placed within that cell. shape_type_grid (Dict[Point, ArithRef]): A dictionary of z3 constants of shape types. Each cell contains the index of the shape type placed in that cell (as indexed by the shapes list passed in to the ShapeConstrainer constructor), or -1 if no shape is placed within that cell. solver (z3.Solver): The Solver associated with this ShapeConstrainer . print_shape_types ShapeConstrainer.print_shape_types(self) Prints the shape type assigned to each cell. Should be called only after the solver has been checked. print_shape_instances ShapeConstrainer.print_shape_instances(self) Prints the shape instance ID assigned to each cell. Should be called only after the solver has been checked.","title":"Shapes"},{"location":"sightlines/","text":"grilops.sightlines This module supports puzzles that must check sightlines through grids. A sightline is a straight line through a symbol grid. It may have a stopping condition, determined based on the symbol encountered in the grid, which, when satisfied, results in no further symbols along the line being counted. It may also have a custom counting or accumulation function. A sightline always stops when it reaches a point not in the grid. So, if the grid is not convex, a sightline might stop at a hole in the middle of the grid. If it is desired that a sightline continues through such holes, the holes should be treated as part of the grid, e.g., as black cells. count_cells count_cells(symbol_grid:grilops.grids.SymbolGrid, start:grilops.geometry.Point, direction:grilops.geometry.Vector, count:Callable[[z3.z3.ArithRef], z3.z3.ArithRef]=<function <lambda> at 0x7fe22d90df28>, stop:Callable[[z3.z3.ArithRef], z3.z3.BoolRef]=<function <lambda> at 0x7fe22d933048>) Returns a count of cells along a sightline through a grid. Arguments symbol_grid (SymbolGrid) : The SymbolGrid to check against. start (Point) : The location of the cell where the sightline should begin. This is the first cell checked. direction (Vector) : The direction to advance to reach the next cell in the sightline. count (Callable[[ArithRef], ArithRef]) : A function that accepts a symbol as an argument and returns the integer value to add to the count when this symbol is encountered. By default, each symbol will count with a value of one. stop (Callable[[ArithRef], BoolRef]) : A function that accepts a symbol as an argument and returns True if we should stop following the sightline when this symbol is encountered. By default, the sightline will continue to the edge of the grid. reduce_cells reduce_cells(symbol_grid:grilops.grids.SymbolGrid, start:grilops.geometry.Point, direction:grilops.geometry.Vector, initializer:~Accumulator, accumulate:Callable[[~Accumulator, z3.z3.ArithRef], ~Accumulator], stop:Callable[[~Accumulator, z3.z3.ArithRef], z3.z3.BoolRef]=<function <lambda> at 0x7fe22d933158>) Returns a computation of a sightline through a grid. Arguments symbol_grid (SymbolGrid) : The SymbolGrid to check against. start (Point) : The location of the cell where the sightline should begin. This is the first cell checked. direction (Vector) : The direction to advance to reach the next cell in the sightline. initializer (Accumulator) : The initial value for the accumulator. accumulate (Callable[[Accumulator, ArithRef], Accumulator]) : A function that accepts an accumulated value and a symbol as arguments, and returns a new accumulated value. This function is used to determine a new accumulated value for each cell along the sightline, based on the accumulated value from the previously encountered cells as well as the symbol in the current cell. stop (Callable[[Accumulator, ArithRef], BoolRef]) : A function that accepts an accumulated value and a symbol as arguments, and returns True if we should stop following the sightline when this symbol is encountered. By default, the sightline will continue to the edge of the grid.","title":"Sightlines"},{"location":"symbols/","text":"grilops.symbols This module supports defining symbols that may be filled into grid cells. Symbol Symbol(self, index:int, name:Union[str, NoneType]=None, label:Union[str, NoneType]=None) A marking that may be filled into a single SymbolGrid cell. Arguments index (int) : The index value assigned to the symbol. name (str, None) : The Python-safe name of the symbol. label (str, None) : The printable label of the symbol. index (int): The index value assigned to the symbol. label (str): The printable label of the symbol. name (str): The Python-safe name of the symbol. SymbolSet SymbolSet(self, symbols:List[Union[str, Tuple[str, str], Tuple[str, str, int]]]) The complete set of markings allowed to be filled into a SymbolGrid . Arguments symbols (List[Union[str, Tuple[str, str], Tuple[str, str, int]]]) : A list of specifications for the symbols. Each specification may be a Python-safe name, a (Python-safe name, printable label) tuple, or a (Python-safe name, printable label, index value) tuple. symbols (Dict[int, Symbol]): The map of all symbols. append SymbolSet.append(self, name:str=None, label:str=None) Appends an additional symbol to this symbol set. Arguments name (str, None) : The Python-safe name of the symbol. label (str, None) : The printable label of the symbol. min_index SymbolSet.min_index(self) Returns the minimum index value of all of the symbols. max_index SymbolSet.max_index(self) Returns the maximum index value of all of the symbols. make_letter_range_symbol_set make_letter_range_symbol_set(min_letter:str, max_letter:str) -> grilops.symbols.SymbolSet Returns a SymbolSet consisting of consecutive letters. Arguments min_letter (str) : The lowest letter to include in the set. max_letter (str) : The highest letter to include in the set. Returns (SymbolSet) : A SymbolSet consisting of consecutive letters. make_number_range_symbol_set make_number_range_symbol_set(min_number:int, max_number:int) -> grilops.symbols.SymbolSet Returns a SymbolSet consisting of consecutive numbers. The names of the symbols will be prefixed with S so that they may be referred to directly in Python code. Arguments min_number (int) : The lowest number to include in the set. max_number (int) : The highest number to include in the set. Returns (SymbolSet) : A SymbolSet consisting of consecutive numbers.","title":"Symbols"}]}