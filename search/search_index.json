{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"grilops a GRId LOgic Puzzle Solver library, using Python 3 and z3 .","title":"Home"},{"location":"#grilops","text":"a GRId LOgic Puzzle Solver library, using Python 3 and z3 .","title":"grilops"},{"location":"api/","text":"grilops.grids Code to construct grids that may have symbols filled in. SymbolGrid SymbolGrid(self, height:int, width:int, symbol_set:grilops.symbols.SymbolSet, solver:z3.z3.Solver=None) A grid of cells that can be solved to contain specific symbols. grid list(list(ArithRef)): The grid of z3 variables modeling the cells. solver Solver: The z3 Solver object associated with this SymbolGrid. symbol_set SymbolSet: The SymbolSet associated with this SymbolGrid. neighbors SymbolGrid.neighbors(self, y:int, x:int) -> List[z3.z3.ArithRef] Returns a list of cells orthogonally adjacent to the given cell. Returns: list(ArithRef): A list of cells orthogonally adjacent to the given cell. cell_is SymbolGrid.cell_is(self, y:int, x:int, value:int) -> z3.z3.BoolRef Returns an expression for whether this cell contains this value. Args: y (int): The y-coordinate in the grid. x (int): The x-coordinate in the grid. value (int): The value to satisfy the expression. Returns: BoolRef: an expression that's true if and only if the cell at (y, x) contains this value. cell_is_one_of SymbolGrid.cell_is_one_of(self, y:int, x:int, values:List[int]) -> z3.z3.BoolRef Returns an expression for whether this cell contains one of these values. Args: y (int): The y-coordinate in the grid. x (int): The x-coordinate in the grid. values (list(int)): The list of values to satisfy the expression. Returns: BoolRef: an expression that's true if and only if the cell at (y, x) contains one of the values. solve SymbolGrid.solve(self) -> bool Returns true if the puzzle has a solution, false otherwise. is_unique SymbolGrid.is_unique(self) -> bool Returns true if the solution to the puzzle is unique, false otherwise. Should be called only after solve() has already completed successfully. print SymbolGrid.print(self, hook_function=None) Prints the solved grid using symbol labels. Should be called only after solve() has already completed successfully. Args: hook_function (:obj: function , optional): A function implementing custom symbol display behavior, or None. If this function is provided, it will be called for each cell in the grid, with the arguments y (int), x (int), and the symbol index for that cell (int). It may return a string to print for that cell, or None to keep the default behavior. grilops.symbols Code to define symbols that may be filled into grid cells. Symbol Symbol(self, index:int, name:Union[str, NoneType]=None, label:Union[str, NoneType]=None) A marking that may be filled into a single grid cell. index int: The index value assigned to the symbol. label str: The printable label of the symbol. name str: The Python-safe name of the symbol. SymbolSet SymbolSet(self, names:List[str]=None, labels:List[str]=None) The complete set of markings allowed to be filled into the grid. symbols list(Symbol): The list of all symbols. append SymbolSet.append(self, name:str=None, label:str=None) Appends an additional smybol to this symbol set. Args: name (:obj: str , optional): The Python-safe name of the symbol. label (:obj: str , optional): The printable label of the symbol. make_letter_range_symbol_set make_letter_range_symbol_set(min_letter:str, max_letter:str) -> grilops.symbols.SymbolSet Returns a symbol set consisting of consecutive letters. Args: min_letter (str): The lowest letter to include in the set. max_letter (str): The highest letter to include in the set. make_number_range_symbol_set make_number_range_symbol_set(min_number:int, max_number:int) -> grilops.symbols.SymbolSet Returns a symbol set consisting of consecutive numbers. The names of the symbols will be prefixed with S so that they may be referred to directly in Python code. Args: min_number (int): The lowest number to include in the set. max_number (int): The highest number to include in the set. grilops.loops Support for puzzles where closed loops are filled into a grid. LoopSymbolSet LoopSymbolSet(self) A symbol set consisting of symbols that may form loops. is_loop LoopSymbolSet.is_loop(self, symbol_variable:z3.z3.ArithRef) -> z3.z3.BoolRef Returns true if the symbol represents part of the loop. Args: symbol_variable (ArithRef): A z3 variable representing a symbol. Returns: BoolRef: true if the symbol represents part of the loop. add_loop_edge_constraints add_loop_edge_constraints(symbol_grid:grilops.grids.SymbolGrid) Constrain the grid to ensure loops are closed. add_single_loop_constraints add_single_loop_constraints(symbol_grid:grilops.grids.SymbolGrid) -> List[List[z3.z3.ArithRef]] Constrain the grid to ensure a single continuous loop. Returns: list(list(ArithRef)): A grid of loop index variables. grilops.regions Support for puzzles where cells must be grouped into contiguous regions. RegionConstrainer RegionConstrainer(self, height:int, width:int, solver:z3.z3.Solver=None, complete:bool=True) Models constraints for grouping cells into contiguous regions. parent_grid list(list(ArithRef)): The grid of z3 variables of parent pointers. region_id_grid list(list(ArithRef)): The grid of z3 variables identifying regions. region_size_grid list(list(ArithRef)): The grid of z3 variables of region sizes. solver Solver: The z3 Solver object associated with this RegionConstrainer. print_trees RegionConstrainer.print_trees(self) Prints the region parent assigned to each cell. Should be called only after the solver has been checked. print_subtree_sizes RegionConstrainer.print_subtree_sizes(self) Prints the region subtree size of each cell. Should be called only after the solver has been checked. print_region_ids RegionConstrainer.print_region_ids(self) Prints a number identifying the region that owns each cell. Should be called only after the solver has been checked. print_region_sizes RegionConstrainer.print_region_sizes(self) Prints the size of the region that contains each cell. Should be called only after the solver has been checked.","title":"API"}]}