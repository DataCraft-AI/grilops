{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"grilops a GRId LOgic Puzzle Solver library, using Python 3 and z3 . This package contains a collection of libraries and helper functions that are useful for solving and checking Nikoli -style logic puzzles using z3. To get a feel for how to use this package to model and solve puzzles, try working through the tutorial IPython notebook , and refer to the examples and the API Documentation . Basic Concepts and Usage The symbols and grids modules contain the core functionality needed for modeling most puzzles. For convenience, their attributes can be accessed directly from the top-level grilops module. Symbols represent the marks that are determined and written into a grid by a solver while solving a puzzle. For example, the symbol set of a Sudoku puzzle would be the digits 1 through 9. The symbol set of a binary determination puzzle such as Nurikabe could contain two symbols, one representing a black cell and the other representing a white cell. A symbol grid is used to keep track of the assignment of symbols to grid cells. Generally, setting up a program to solve a puzzle using grilops involves: Constructing a symbol set Constructing a symbol grid limited to contain symbols from that symbol set Adding puzzle-specific constraints to cells in the symbol grid Checking for satisfying assignments of symbols to symbol grid cells Grid cells are exposed as z3 constants, so built-in z3 operators can and should be used when adding puzzle-specific constraints. In addition, grilops provides several modules to help automate and abstract away the introduction of common kinds of constraints. Loops The grilops.loops module is helpful for adding constraints that ensure symbols connect to form closed loops. An example of a puzzle type for which this is useful is Masyu . Regions The grilops.regions module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of variable shapes and sizes. Some examples of puzzle types for which this is useful are Nurikabe and Fillomino . Shapes The grilops.shapes module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of fixed shapes and sizes. Some examples of puzzle types for which this is useful are Battleship and LITS .","title":"Home"},{"location":"#grilops","text":"a GRId LOgic Puzzle Solver library, using Python 3 and z3 . This package contains a collection of libraries and helper functions that are useful for solving and checking Nikoli -style logic puzzles using z3. To get a feel for how to use this package to model and solve puzzles, try working through the tutorial IPython notebook , and refer to the examples and the API Documentation .","title":"grilops"},{"location":"#basic-concepts-and-usage","text":"The symbols and grids modules contain the core functionality needed for modeling most puzzles. For convenience, their attributes can be accessed directly from the top-level grilops module. Symbols represent the marks that are determined and written into a grid by a solver while solving a puzzle. For example, the symbol set of a Sudoku puzzle would be the digits 1 through 9. The symbol set of a binary determination puzzle such as Nurikabe could contain two symbols, one representing a black cell and the other representing a white cell. A symbol grid is used to keep track of the assignment of symbols to grid cells. Generally, setting up a program to solve a puzzle using grilops involves: Constructing a symbol set Constructing a symbol grid limited to contain symbols from that symbol set Adding puzzle-specific constraints to cells in the symbol grid Checking for satisfying assignments of symbols to symbol grid cells Grid cells are exposed as z3 constants, so built-in z3 operators can and should be used when adding puzzle-specific constraints. In addition, grilops provides several modules to help automate and abstract away the introduction of common kinds of constraints.","title":"Basic Concepts and Usage"},{"location":"#loops","text":"The grilops.loops module is helpful for adding constraints that ensure symbols connect to form closed loops. An example of a puzzle type for which this is useful is Masyu .","title":"Loops"},{"location":"#regions","text":"The grilops.regions module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of variable shapes and sizes. Some examples of puzzle types for which this is useful are Nurikabe and Fillomino .","title":"Regions"},{"location":"#shapes","text":"The grilops.shapes module is helpful for adding constraints that ensure cells are grouped into orthogonally contiguous regions (polyominos) of fixed shapes and sizes. Some examples of puzzle types for which this is useful are Battleship and LITS .","title":"Shapes"},{"location":"grids/","text":"grilops.grids This module supports constructing and working with grids of cells. adjacent_cells adjacent_cells(grid:List[List[z3.z3.ArithRef]], y:int, x:int) -> List[z3.z3.ArithRef] Returns a list of cells orthogonally adjacent to the given cell. Arguments grid (List[List[z3.ArithRef]]) : A grid of z3 constants. y (int) : y-coordinate of the given cell. x (int) : x-coordinate of the given cell. Returns (List[z3.ArithRef]) : The cells orthogonally adjacent to the given cell. touching_cells touching_cells(grid:List[List[z3.z3.ArithRef]], y:int, x:int) -> List[z3.z3.ArithRef] Returns the cells touching the given cell (orthogonally and diagonally). Arguments grid (List[List[z3.ArithRef]]) : A grid of z3 constants. y (int) : y-coordinate of the given cell. x (int) : x-coordinate of the given cell. Returns (List[ArithRef]) : The cells touching the given cell. SymbolGrid SymbolGrid(self, height:int, width:int, symbol_set:grilops.symbols.SymbolSet, solver:z3.z3.Solver=None) A grid of cells that can be solved to contain specific symbols. Arguments height (int) : The height of the grid. width (int) : The width of the grid. symbol_set (SymbolSet) : The set of symbols to be filled into the grid. solver (z3.Solver, None) : A Solver object. If None, a Solver will be constructed. grid (List[List[z3.ArithRef]]): The grid of cells. solver (z3.Solver): The Solver object associated with this SymbolGrid . symbol_set (SymbolSet): The SymbolSet associated with this SymbolGrid . adjacent_cells SymbolGrid.adjacent_cells(self, y:int, x:int) -> List[z3.z3.ArithRef] Returns a list of cells orthogonally adjacent to the given cell. Arguments y (int) : y-coordinate of the given cell. x (int) : x-coordinate of the given cell. Returns (List[z3.ArithRef]) : The cells orthogonally adjacent to the given cell. touching_cells SymbolGrid.touching_cells(self, y:int, x:int) -> List[z3.z3.ArithRef] Returns the cells touching the given cell (orthogonally and diagonally). Arguments y (int) : y-coordinate of the given cell. x (int) : x-coordinate of the given cell. Returns (List[ArithRef]) : The cells touching the given cell. cell_is SymbolGrid.cell_is(self, y:int, x:int, value:int) -> z3.z3.BoolRef Returns an expression for whether this cell contains this value. Arguments y (int) : The y-coordinate in the grid. x (int) : The x-coordinate in the grid. value (int) : The value to satisfy the expression. Returns (z3.BoolRef) : an expression that's true if and only if the cell at (y, x) contains this value. cell_is_one_of SymbolGrid.cell_is_one_of(self, y:int, x:int, values:List[int]) -> z3.z3.BoolRef Returns an expression for whether this cell contains one of these values. Arguments y (int) : The y-coordinate in the grid. x (int) : The x-coordinate in the grid. values (list(int)) : The list of values to satisfy the expression. Returns (z3.BoolRef) : an expression that's true if and only if the cell at (y, x) contains one of the values. solve SymbolGrid.solve(self) -> bool Returns true if the puzzle has a solution, false otherwise. is_unique SymbolGrid.is_unique(self) -> bool Returns true if the solution to the puzzle is unique, false otherwise. Should be called only after SymbolGrid.solve() has already completed successfully. solved_grid SymbolGrid.solved_grid(self) -> List[List[int]] Returns the solved symbol grid. Should be called only after SymbolGrid.solve() has already completed successfully. print SymbolGrid.print(self, hook_function=None) Prints the solved grid using symbol labels. Should be called only after SymbolGrid.solve() has already completed successfully. Arguments hook_function (function, None) : A function implementing custom symbol display behavior, or None. If this function is provided, it will be called for each cell in the grid, with the arguments y (int), x (int), and the symbol index for that cell (int). It may return a string to print for that cell, or None to keep the default behavior.","title":"Grids"},{"location":"loops/","text":"grilops.loops This module supports puzzles where closed loops are filled into a grid. LoopSymbolSet LoopSymbolSet(self) A SymbolSet consisting of symbols that may form loops. Additional symbols (e.g. a Symbol representing an empty space) may be added to this SymbolSet by calling SymbolSet.append() after it's constructed. Attributes NS : The Symbol connecting the cells above and below. EW : The Symbol connecting the cells to the left and to the right. NE : The Symbol connecting the cells above and to the right. SE : The Symbol connecting the cells below and to the right. SW : The Symbol connecting the cells below and to the left. NW : The Symbol connecting the cells above and to the left. is_loop LoopSymbolSet.is_loop(self, symbol:z3.z3.ArithRef) -> z3.z3.BoolRef Returns true if symbol represents part of the loop. Arguments symbol (z3.ArithRef) : A z3 expression representing a symbol. Returns (z3.BoolRef) : true if the symbol represents part of the loop. add_loop_edge_constraints add_loop_edge_constraints(symbol_grid:grilops.grids.SymbolGrid) Constrain symbol_grid to ensure loops are closed. add_single_loop_constraints add_single_loop_constraints(symbol_grid:grilops.grids.SymbolGrid) -> List[List[z3.z3.ArithRef]] Constrain symbol_grid to ensure a single continuous loop. Returns List[List[ArithRef]] : A grid of variables representing a loop traversal order. May be useful for debugging.","title":"Loops"},{"location":"regions/","text":"grilops.regions This module supports puzzles that group cells into contiguous regions. Internally, the RegionConstrainer constructs subtrees, each spanning the cells contained within a region. Aspects of a cell's relationship to the other cells in its subtree are exposed by properties of the RegionConstrainer . Attributes X (int) : The RegionConstrainer.parent_grid value indicating that a cell is not part of a region. R (int) : The RegionConstrainer.parent_grid value indicating that a cell is the root of its region's subtree. N (int) : The RegionConstrainer.parent_grid value indicating that a cell is the child of the cell above it in its region's subtree. E (int) : The RegionConstrainer.parent_grid value indicating that a cell is the child of the cell to the right of it in its region's subtree. S (int) : The RegionConstrainer.parent_grid value indicating that a cell is the child of the cell below it in its region's subtree. W (int) : The RegionConstrainer.parent_grid value indicating that a cell is the child of the cell to the left of it in its region's subtree. RegionConstrainer RegionConstrainer(self, height:int, width:int, solver:z3.z3.Solver=None, complete:bool=True, max_region_size:Union[int, NoneType]=None) Creates constraints for grouping cells into contiguous regions. Arguments height (int) : The height of the grid. width (int) : The width of the grid. solver (z3.Solver, None) : A Solver object. If None, a Solver will be constructed. complete (bool) : If true, every cell must be part of a region. Defaults to true. max_region_size(int, None) : The maximum possible size of a region. parent_grid (List[List[ArithRef]]): A grid of region subtree parent pointers. The values that may be present in this grid are the module attributes X , R , N , E , S , and W . region_id_grid (List[List[ArithRef]]): A grid of numbers identifying regions. A region's identifier is the position in the grid (going in order from left to right, top to bottom) of the root of that region's subtree. region_size_grid (List[List[ArithRef]]): A grid of region sizes. solver (z3.Solver): The Solver associated with this RegionConstrainer . subtree_size_grid (List[List[ArithRef]]): A grid of cell subtree sizes. A cell's subtree size is one plus the number of cells that are descendents of the cell in its region's subtree. print_trees RegionConstrainer.print_trees(self) Prints the region parent assigned to each cell. Should be called only after the solver has been checked. print_subtree_sizes RegionConstrainer.print_subtree_sizes(self) Prints the region subtree size of each cell. Should be called only after the solver has been checked. print_region_ids RegionConstrainer.print_region_ids(self) Prints a number identifying the region that owns each cell. Should be called only after the solver has been checked. print_region_sizes RegionConstrainer.print_region_sizes(self) Prints the size of the region that contains each cell. Should be called only after the solver has been checked.","title":"Regions"},{"location":"shapes/","text":"grilops.shapes This module supports puzzles that place fixed shape regions into the grid. rotate_shape_clockwise rotate_shape_clockwise(shape) Returns a new shape coordinate list rotated 90 degrees clockwise. Arguments: shape (List[Tuple[int, int]]): A list of (y, x) coordinates defining a shape. Returns: (List[Tuple[int, int]]): A list of (y, x) coordinates defining the 90-degree clockwise rotation of the input shape. reflect_shape_y reflect_shape_y(shape) Returns a new shape coordinate list reflected vertically. Arguments: shape (List[Tuple[int, int]]): A list of (y, x) coordinates defining a shape. Returns: (List[Tuple[int, int]]): A list of (y, x) coordinates defining the vertical reflection of the input shape. reflect_shape_x reflect_shape_x(shape) Returns a new shape coordinate list reflected horizontally. Arguments: shape (List[Tuple[int, int]]): A list of (y, x) coordinates defining a shape. Returns: (List[Tuple[int, int]]): A list of (y, x) coordinates defining the horizontal reflection of the input shape. ShapeConstrainer ShapeConstrainer(self, height:int, width:int, shapes:List[List[Tuple[int, int]]], solver:z3.z3.Solver=None, complete:bool=False, allow_rotations:bool=False, allow_reflections:bool=False, allow_copies:bool=False) Creates constraints for placing fixed shape regions into the grid. Arguments height (int) : The height of the grid. width (int) : The width of the grid. shapes (List[List[Tuple[int, int]]]) : A list of region shape definitions. Each region shape definition should be a list of (y, x) tuples. The same region shape definition may be included multiple times to indicate the number of times that shape may appear (if allow_copies is false). solver (z3.Solver, None) : A Solver object. If None, a Solver will be constructed. complete (bool) : If true, every cell must be part of a shape region. Defaults to false. allow_rotations (bool) : If true, allow rotations of the shapes to be placed in the grid. Defaults to false. allow_reflections (bool) : If true, allow reflections of the shapes to be placed in the grid. Defaults to false. allow_copies (bool) : If true, allow any number of copies of the shapes to be placed in the grid. Defaults to false. shape_instance_grid (List[List[ArithRef]]): A grid of z3 constants of shape instance IDs. Each cell contains a number shared among all cells containing the same instance of the shape, or -1 if no shape is placed within that cell. shape_type_grid (List[List[ArithRef]]): A grid of z3 constants of shape types. Each cell contains the index of the shape type placed in that cell (as indexed by the shapes list passed in to the ShapeConstrainer constructor), or -1 if no shape is placed within that cell. solver (z3.Solver): The Solver associated with this ShapeConstrainer . print_shape_types ShapeConstrainer.print_shape_types(self) Prints the shape type assigned to each cell. Should be called only after the solver has been checked. print_shape_instances ShapeConstrainer.print_shape_instances(self) Prints the shape instance ID assigned to each cell. Should be called only after the solver has been checked.","title":"Shapes"},{"location":"symbols/","text":"grilops.symbols This module supports defining symbols that may be filled into grid cells. Symbol Symbol(self, index:int, name:Union[str, NoneType]=None, label:Union[str, NoneType]=None) A marking that may be filled into a single SymbolGrid cell. Arguments index (int) : The index value assigned to the symbol. name (str, None) : The Python-safe name of the symbol. label (str, None) : The printable label of the symbol. index (int): The index value assigned to the symbol. label (str): The printable label of the symbol. name (str): The Python-safe name of the symbol. SymbolSet SymbolSet(self, symbols:List[Union[str, Tuple[str, str], Tuple[str, str, int]]]) The complete set of markings allowed to be filled into a SymbolGrid . Arguments symbols (List[Union[str, Tuple[str, str], Tuple[str, str, int]]]) : A list of specifications for the symbols. Each specification may be a Python-safe name, a (Python-safe name, printabel label) tuple, or a (Python-safe name, printabel label, index value) tuple. symbols (Dict[int, Symbol]): The map of all symbols. append SymbolSet.append(self, name:str=None, label:str=None) Appends an additional symbol to this symbol set. Arguments name (str, None) : The Python-safe name of the symbol. label (str, None) : The printable label of the symbol. min_index SymbolSet.min_index(self) Returns the minimum index value of all of the symbols. max_index SymbolSet.max_index(self) Returns the maximum index value of all of the symbols. make_letter_range_symbol_set make_letter_range_symbol_set(min_letter:str, max_letter:str) -> grilops.symbols.SymbolSet Returns a SymbolSet consisting of consecutive letters. Arguments min_letter (str) : The lowest letter to include in the set. max_letter (str) : The highest letter to include in the set. Returns (SymbolSet) : A SymbolSet consisting of consecutive letters. make_number_range_symbol_set make_number_range_symbol_set(min_number:int, max_number:int) -> grilops.symbols.SymbolSet Returns a SymbolSet consisting of consecutive numbers. The names of the symbols will be prefixed with S so that they may be referred to directly in Python code. Arguments min_number (int) : The lowest number to include in the set. max_number (int) : The highest number to include in the set. Returns (SymbolSet) : A SymbolSet consisting of consecutive numbers.","title":"Symbols"}]}